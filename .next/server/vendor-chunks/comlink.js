"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/comlink";
exports.ids = ["vendor-chunks/comlink"];
exports.modules = {

/***/ "(ssr)/./node_modules/comlink/dist/esm/comlink.mjs":
/*!***************************************************!*\
  !*** ./node_modules/comlink/dist/esm/comlink.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createEndpoint: () => (/* binding */ createEndpoint),\n/* harmony export */   expose: () => (/* binding */ expose),\n/* harmony export */   finalizer: () => (/* binding */ finalizer),\n/* harmony export */   proxy: () => (/* binding */ proxy),\n/* harmony export */   proxyMarker: () => (/* binding */ proxyMarker),\n/* harmony export */   releaseProxy: () => (/* binding */ releaseProxy),\n/* harmony export */   transfer: () => (/* binding */ transfer),\n/* harmony export */   transferHandlers: () => (/* binding */ transferHandlers),\n/* harmony export */   windowEndpoint: () => (/* binding */ windowEndpoint),\n/* harmony export */   wrap: () => (/* binding */ wrap)\n/* harmony export */ });\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ const proxyMarker = Symbol(\"Comlink.proxy\");\nconst createEndpoint = Symbol(\"Comlink.endpoint\");\nconst releaseProxy = Symbol(\"Comlink.releaseProxy\");\nconst finalizer = Symbol(\"Comlink.finalizer\");\nconst throwMarker = Symbol(\"Comlink.thrown\");\nconst isObject = (val)=>typeof val === \"object\" && val !== null || typeof val === \"function\";\n/**\n * Internal transfer handle to handle objects marked to proxy.\n */ const proxyTransferHandler = {\n    canHandle: (val)=>isObject(val) && val[proxyMarker],\n    serialize (obj) {\n        const { port1, port2 } = new MessageChannel();\n        expose(obj, port1);\n        return [\n            port2,\n            [\n                port2\n            ]\n        ];\n    },\n    deserialize (port) {\n        port.start();\n        return wrap(port);\n    }\n};\n/**\n * Internal transfer handler to handle thrown exceptions.\n */ const throwTransferHandler = {\n    canHandle: (value)=>isObject(value) && throwMarker in value,\n    serialize ({ value }) {\n        let serialized;\n        if (value instanceof Error) {\n            serialized = {\n                isError: true,\n                value: {\n                    message: value.message,\n                    name: value.name,\n                    stack: value.stack\n                }\n            };\n        } else {\n            serialized = {\n                isError: false,\n                value\n            };\n        }\n        return [\n            serialized,\n            []\n        ];\n    },\n    deserialize (serialized) {\n        if (serialized.isError) {\n            throw Object.assign(new Error(serialized.value.message), serialized.value);\n        }\n        throw serialized.value;\n    }\n};\n/**\n * Allows customizing the serialization of certain values.\n */ const transferHandlers = new Map([\n    [\n        \"proxy\",\n        proxyTransferHandler\n    ],\n    [\n        \"throw\",\n        throwTransferHandler\n    ]\n]);\nfunction isAllowedOrigin(allowedOrigins, origin) {\n    for (const allowedOrigin of allowedOrigins){\n        if (origin === allowedOrigin || allowedOrigin === \"*\") {\n            return true;\n        }\n        if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction expose(obj, ep = globalThis, allowedOrigins = [\n    \"*\"\n]) {\n    ep.addEventListener(\"message\", function callback(ev) {\n        if (!ev || !ev.data) {\n            return;\n        }\n        if (!isAllowedOrigin(allowedOrigins, ev.origin)) {\n            console.warn(`Invalid origin '${ev.origin}' for comlink proxy`);\n            return;\n        }\n        const { id, type, path } = Object.assign({\n            path: []\n        }, ev.data);\n        const argumentList = (ev.data.argumentList || []).map(fromWireValue);\n        let returnValue;\n        try {\n            const parent = path.slice(0, -1).reduce((obj, prop)=>obj[prop], obj);\n            const rawValue = path.reduce((obj, prop)=>obj[prop], obj);\n            switch(type){\n                case \"GET\" /* MessageType.GET */ :\n                    {\n                        returnValue = rawValue;\n                    }\n                    break;\n                case \"SET\" /* MessageType.SET */ :\n                    {\n                        parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\n                        returnValue = true;\n                    }\n                    break;\n                case \"APPLY\" /* MessageType.APPLY */ :\n                    {\n                        returnValue = rawValue.apply(parent, argumentList);\n                    }\n                    break;\n                case \"CONSTRUCT\" /* MessageType.CONSTRUCT */ :\n                    {\n                        const value = new rawValue(...argumentList);\n                        returnValue = proxy(value);\n                    }\n                    break;\n                case \"ENDPOINT\" /* MessageType.ENDPOINT */ :\n                    {\n                        const { port1, port2 } = new MessageChannel();\n                        expose(obj, port2);\n                        returnValue = transfer(port1, [\n                            port1\n                        ]);\n                    }\n                    break;\n                case \"RELEASE\" /* MessageType.RELEASE */ :\n                    {\n                        returnValue = undefined;\n                    }\n                    break;\n                default:\n                    return;\n            }\n        } catch (value) {\n            returnValue = {\n                value,\n                [throwMarker]: 0\n            };\n        }\n        Promise.resolve(returnValue).catch((value)=>{\n            return {\n                value,\n                [throwMarker]: 0\n            };\n        }).then((returnValue)=>{\n            const [wireValue, transferables] = toWireValue(returnValue);\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), {\n                id\n            }), transferables);\n            if (type === \"RELEASE\" /* MessageType.RELEASE */ ) {\n                // detach and deactive after sending release response above.\n                ep.removeEventListener(\"message\", callback);\n                closeEndPoint(ep);\n                if (finalizer in obj && typeof obj[finalizer] === \"function\") {\n                    obj[finalizer]();\n                }\n            }\n        }).catch((error)=>{\n            // Send Serialization Error To Caller\n            const [wireValue, transferables] = toWireValue({\n                value: new TypeError(\"Unserializable return value\"),\n                [throwMarker]: 0\n            });\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), {\n                id\n            }), transferables);\n        });\n    });\n    if (ep.start) {\n        ep.start();\n    }\n}\nfunction isMessagePort(endpoint) {\n    return endpoint.constructor.name === \"MessagePort\";\n}\nfunction closeEndPoint(endpoint) {\n    if (isMessagePort(endpoint)) endpoint.close();\n}\nfunction wrap(ep, target) {\n    const pendingListeners = new Map();\n    ep.addEventListener(\"message\", function handleMessage(ev) {\n        const { data } = ev;\n        if (!data || !data.id) {\n            return;\n        }\n        const resolver = pendingListeners.get(data.id);\n        if (!resolver) {\n            return;\n        }\n        try {\n            resolver(data);\n        } finally{\n            pendingListeners.delete(data.id);\n        }\n    });\n    return createProxy(ep, pendingListeners, [], target);\n}\nfunction throwIfProxyReleased(isReleased) {\n    if (isReleased) {\n        throw new Error(\"Proxy has been released and is not useable\");\n    }\n}\nfunction releaseEndpoint(ep) {\n    return requestResponseMessage(ep, new Map(), {\n        type: \"RELEASE\" /* MessageType.RELEASE */ \n    }).then(()=>{\n        closeEndPoint(ep);\n    });\n}\nconst proxyCounter = new WeakMap();\nconst proxyFinalizers = \"FinalizationRegistry\" in globalThis && new FinalizationRegistry((ep)=>{\n    const newCount = (proxyCounter.get(ep) || 0) - 1;\n    proxyCounter.set(ep, newCount);\n    if (newCount === 0) {\n        releaseEndpoint(ep);\n    }\n});\nfunction registerProxy(proxy, ep) {\n    const newCount = (proxyCounter.get(ep) || 0) + 1;\n    proxyCounter.set(ep, newCount);\n    if (proxyFinalizers) {\n        proxyFinalizers.register(proxy, ep, proxy);\n    }\n}\nfunction unregisterProxy(proxy) {\n    if (proxyFinalizers) {\n        proxyFinalizers.unregister(proxy);\n    }\n}\nfunction createProxy(ep, pendingListeners, path = [], target = function() {}) {\n    let isProxyReleased = false;\n    const proxy = new Proxy(target, {\n        get (_target, prop) {\n            throwIfProxyReleased(isProxyReleased);\n            if (prop === releaseProxy) {\n                return ()=>{\n                    unregisterProxy(proxy);\n                    releaseEndpoint(ep);\n                    pendingListeners.clear();\n                    isProxyReleased = true;\n                };\n            }\n            if (prop === \"then\") {\n                if (path.length === 0) {\n                    return {\n                        then: ()=>proxy\n                    };\n                }\n                const r = requestResponseMessage(ep, pendingListeners, {\n                    type: \"GET\" /* MessageType.GET */ ,\n                    path: path.map((p)=>p.toString())\n                }).then(fromWireValue);\n                return r.then.bind(r);\n            }\n            return createProxy(ep, pendingListeners, [\n                ...path,\n                prop\n            ]);\n        },\n        set (_target, prop, rawValue) {\n            throwIfProxyReleased(isProxyReleased);\n            // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\n            // boolean. To show good will, we return true asynchronously ¯\\_(ツ)_/¯\n            const [value, transferables] = toWireValue(rawValue);\n            return requestResponseMessage(ep, pendingListeners, {\n                type: \"SET\" /* MessageType.SET */ ,\n                path: [\n                    ...path,\n                    prop\n                ].map((p)=>p.toString()),\n                value\n            }, transferables).then(fromWireValue);\n        },\n        apply (_target, _thisArg, rawArgumentList) {\n            throwIfProxyReleased(isProxyReleased);\n            const last = path[path.length - 1];\n            if (last === createEndpoint) {\n                return requestResponseMessage(ep, pendingListeners, {\n                    type: \"ENDPOINT\" /* MessageType.ENDPOINT */ \n                }).then(fromWireValue);\n            }\n            // We just pretend that `bind()` didn’t happen.\n            if (last === \"bind\") {\n                return createProxy(ep, pendingListeners, path.slice(0, -1));\n            }\n            const [argumentList, transferables] = processArguments(rawArgumentList);\n            return requestResponseMessage(ep, pendingListeners, {\n                type: \"APPLY\" /* MessageType.APPLY */ ,\n                path: path.map((p)=>p.toString()),\n                argumentList\n            }, transferables).then(fromWireValue);\n        },\n        construct (_target, rawArgumentList) {\n            throwIfProxyReleased(isProxyReleased);\n            const [argumentList, transferables] = processArguments(rawArgumentList);\n            return requestResponseMessage(ep, pendingListeners, {\n                type: \"CONSTRUCT\" /* MessageType.CONSTRUCT */ ,\n                path: path.map((p)=>p.toString()),\n                argumentList\n            }, transferables).then(fromWireValue);\n        }\n    });\n    registerProxy(proxy, ep);\n    return proxy;\n}\nfunction myFlat(arr) {\n    return Array.prototype.concat.apply([], arr);\n}\nfunction processArguments(argumentList) {\n    const processed = argumentList.map(toWireValue);\n    return [\n        processed.map((v)=>v[0]),\n        myFlat(processed.map((v)=>v[1]))\n    ];\n}\nconst transferCache = new WeakMap();\nfunction transfer(obj, transfers) {\n    transferCache.set(obj, transfers);\n    return obj;\n}\nfunction proxy(obj) {\n    return Object.assign(obj, {\n        [proxyMarker]: true\n    });\n}\nfunction windowEndpoint(w, context = globalThis, targetOrigin = \"*\") {\n    return {\n        postMessage: (msg, transferables)=>w.postMessage(msg, targetOrigin, transferables),\n        addEventListener: context.addEventListener.bind(context),\n        removeEventListener: context.removeEventListener.bind(context)\n    };\n}\nfunction toWireValue(value) {\n    for (const [name, handler] of transferHandlers){\n        if (handler.canHandle(value)) {\n            const [serializedValue, transferables] = handler.serialize(value);\n            return [\n                {\n                    type: \"HANDLER\" /* WireValueType.HANDLER */ ,\n                    name,\n                    value: serializedValue\n                },\n                transferables\n            ];\n        }\n    }\n    return [\n        {\n            type: \"RAW\" /* WireValueType.RAW */ ,\n            value\n        },\n        transferCache.get(value) || []\n    ];\n}\nfunction fromWireValue(value) {\n    switch(value.type){\n        case \"HANDLER\" /* WireValueType.HANDLER */ :\n            return transferHandlers.get(value.name).deserialize(value.value);\n        case \"RAW\" /* WireValueType.RAW */ :\n            return value.value;\n    }\n}\nfunction requestResponseMessage(ep, pendingListeners, msg, transfers) {\n    return new Promise((resolve)=>{\n        const id = generateUUID();\n        pendingListeners.set(id, resolve);\n        if (ep.start) {\n            ep.start();\n        }\n        ep.postMessage(Object.assign({\n            id\n        }, msg), transfers);\n    });\n}\nfunction generateUUID() {\n    return new Array(4).fill(0).map(()=>Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16)).join(\"-\");\n}\n //# sourceMappingURL=comlink.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY29tbGluay9kaXN0L2VzbS9jb21saW5rLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Q0FJQyxHQUNELE1BQU1BLGNBQWNDLE9BQU87QUFDM0IsTUFBTUMsaUJBQWlCRCxPQUFPO0FBQzlCLE1BQU1FLGVBQWVGLE9BQU87QUFDNUIsTUFBTUcsWUFBWUgsT0FBTztBQUN6QixNQUFNSSxjQUFjSixPQUFPO0FBQzNCLE1BQU1LLFdBQVcsQ0FBQ0MsTUFBUSxPQUFRQSxRQUFRLFlBQVlBLFFBQVEsUUFBUyxPQUFPQSxRQUFRO0FBQ3RGOztDQUVDLEdBQ0QsTUFBTUMsdUJBQXVCO0lBQ3pCQyxXQUFXLENBQUNGLE1BQVFELFNBQVNDLFFBQVFBLEdBQUcsQ0FBQ1AsWUFBWTtJQUNyRFUsV0FBVUMsR0FBRztRQUNULE1BQU0sRUFBRUMsS0FBSyxFQUFFQyxLQUFLLEVBQUUsR0FBRyxJQUFJQztRQUM3QkMsT0FBT0osS0FBS0M7UUFDWixPQUFPO1lBQUNDO1lBQU87Z0JBQUNBO2FBQU07U0FBQztJQUMzQjtJQUNBRyxhQUFZQyxJQUFJO1FBQ1pBLEtBQUtDLEtBQUs7UUFDVixPQUFPQyxLQUFLRjtJQUNoQjtBQUNKO0FBQ0E7O0NBRUMsR0FDRCxNQUFNRyx1QkFBdUI7SUFDekJYLFdBQVcsQ0FBQ1ksUUFBVWYsU0FBU2UsVUFBVWhCLGVBQWVnQjtJQUN4RFgsV0FBVSxFQUFFVyxLQUFLLEVBQUU7UUFDZixJQUFJQztRQUNKLElBQUlELGlCQUFpQkUsT0FBTztZQUN4QkQsYUFBYTtnQkFDVEUsU0FBUztnQkFDVEgsT0FBTztvQkFDSEksU0FBU0osTUFBTUksT0FBTztvQkFDdEJDLE1BQU1MLE1BQU1LLElBQUk7b0JBQ2hCQyxPQUFPTixNQUFNTSxLQUFLO2dCQUN0QjtZQUNKO1FBQ0osT0FDSztZQUNETCxhQUFhO2dCQUFFRSxTQUFTO2dCQUFPSDtZQUFNO1FBQ3pDO1FBQ0EsT0FBTztZQUFDQztZQUFZLEVBQUU7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SjtBQUNBLFNBQVNRO0lBQ0wsT0FBTyxJQUFJZCxNQUFNLEdBQ1plLElBQUksQ0FBQyxHQUNMaEYsR0FBRyxDQUFDLElBQU1pRixLQUFLQyxLQUFLLENBQUNELEtBQUtFLE1BQU0sS0FBS0MsT0FBT0MsZ0JBQWdCLEVBQUU3QixRQUFRLENBQUMsS0FDdkU4QixJQUFJLENBQUM7QUFDZDtBQUVpSSxDQUNqSSxvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9maWRnZXQtYmFsbC8uL25vZGVfbW9kdWxlcy9jb21saW5rL2Rpc3QvZXNtL2NvbWxpbmsubWpzPzA4YWEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuY29uc3QgcHJveHlNYXJrZXIgPSBTeW1ib2woXCJDb21saW5rLnByb3h5XCIpO1xuY29uc3QgY3JlYXRlRW5kcG9pbnQgPSBTeW1ib2woXCJDb21saW5rLmVuZHBvaW50XCIpO1xuY29uc3QgcmVsZWFzZVByb3h5ID0gU3ltYm9sKFwiQ29tbGluay5yZWxlYXNlUHJveHlcIik7XG5jb25zdCBmaW5hbGl6ZXIgPSBTeW1ib2woXCJDb21saW5rLmZpbmFsaXplclwiKTtcbmNvbnN0IHRocm93TWFya2VyID0gU3ltYm9sKFwiQ29tbGluay50aHJvd25cIik7XG5jb25zdCBpc09iamVjdCA9ICh2YWwpID0+ICh0eXBlb2YgdmFsID09PSBcIm9iamVjdFwiICYmIHZhbCAhPT0gbnVsbCkgfHwgdHlwZW9mIHZhbCA9PT0gXCJmdW5jdGlvblwiO1xuLyoqXG4gKiBJbnRlcm5hbCB0cmFuc2ZlciBoYW5kbGUgdG8gaGFuZGxlIG9iamVjdHMgbWFya2VkIHRvIHByb3h5LlxuICovXG5jb25zdCBwcm94eVRyYW5zZmVySGFuZGxlciA9IHtcbiAgICBjYW5IYW5kbGU6ICh2YWwpID0+IGlzT2JqZWN0KHZhbCkgJiYgdmFsW3Byb3h5TWFya2VyXSxcbiAgICBzZXJpYWxpemUob2JqKSB7XG4gICAgICAgIGNvbnN0IHsgcG9ydDEsIHBvcnQyIH0gPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgICAgZXhwb3NlKG9iaiwgcG9ydDEpO1xuICAgICAgICByZXR1cm4gW3BvcnQyLCBbcG9ydDJdXTtcbiAgICB9LFxuICAgIGRlc2VyaWFsaXplKHBvcnQpIHtcbiAgICAgICAgcG9ydC5zdGFydCgpO1xuICAgICAgICByZXR1cm4gd3JhcChwb3J0KTtcbiAgICB9LFxufTtcbi8qKlxuICogSW50ZXJuYWwgdHJhbnNmZXIgaGFuZGxlciB0byBoYW5kbGUgdGhyb3duIGV4Y2VwdGlvbnMuXG4gKi9cbmNvbnN0IHRocm93VHJhbnNmZXJIYW5kbGVyID0ge1xuICAgIGNhbkhhbmRsZTogKHZhbHVlKSA9PiBpc09iamVjdCh2YWx1ZSkgJiYgdGhyb3dNYXJrZXIgaW4gdmFsdWUsXG4gICAgc2VyaWFsaXplKHsgdmFsdWUgfSkge1xuICAgICAgICBsZXQgc2VyaWFsaXplZDtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHNlcmlhbGl6ZWQgPSB7XG4gICAgICAgICAgICAgICAgaXNFcnJvcjogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiB2YWx1ZS5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiB2YWx1ZS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBzdGFjazogdmFsdWUuc3RhY2ssXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXJpYWxpemVkID0geyBpc0Vycm9yOiBmYWxzZSwgdmFsdWUgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3NlcmlhbGl6ZWQsIFtdXTtcbiAgICB9LFxuICAgIGRlc2VyaWFsaXplKHNlcmlhbGl6ZWQpIHtcbiAgICAgICAgaWYgKHNlcmlhbGl6ZWQuaXNFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgT2JqZWN0LmFzc2lnbihuZXcgRXJyb3Ioc2VyaWFsaXplZC52YWx1ZS5tZXNzYWdlKSwgc2VyaWFsaXplZC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgc2VyaWFsaXplZC52YWx1ZTtcbiAgICB9LFxufTtcbi8qKlxuICogQWxsb3dzIGN1c3RvbWl6aW5nIHRoZSBzZXJpYWxpemF0aW9uIG9mIGNlcnRhaW4gdmFsdWVzLlxuICovXG5jb25zdCB0cmFuc2ZlckhhbmRsZXJzID0gbmV3IE1hcChbXG4gICAgW1wicHJveHlcIiwgcHJveHlUcmFuc2ZlckhhbmRsZXJdLFxuICAgIFtcInRocm93XCIsIHRocm93VHJhbnNmZXJIYW5kbGVyXSxcbl0pO1xuZnVuY3Rpb24gaXNBbGxvd2VkT3JpZ2luKGFsbG93ZWRPcmlnaW5zLCBvcmlnaW4pIHtcbiAgICBmb3IgKGNvbnN0IGFsbG93ZWRPcmlnaW4gb2YgYWxsb3dlZE9yaWdpbnMpIHtcbiAgICAgICAgaWYgKG9yaWdpbiA9PT0gYWxsb3dlZE9yaWdpbiB8fCBhbGxvd2VkT3JpZ2luID09PSBcIipcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFsbG93ZWRPcmlnaW4gaW5zdGFuY2VvZiBSZWdFeHAgJiYgYWxsb3dlZE9yaWdpbi50ZXN0KG9yaWdpbikpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGV4cG9zZShvYmosIGVwID0gZ2xvYmFsVGhpcywgYWxsb3dlZE9yaWdpbnMgPSBbXCIqXCJdKSB7XG4gICAgZXAuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgZnVuY3Rpb24gY2FsbGJhY2soZXYpIHtcbiAgICAgICAgaWYgKCFldiB8fCAhZXYuZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNBbGxvd2VkT3JpZ2luKGFsbG93ZWRPcmlnaW5zLCBldi5vcmlnaW4pKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYEludmFsaWQgb3JpZ2luICcke2V2Lm9yaWdpbn0nIGZvciBjb21saW5rIHByb3h5YCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBpZCwgdHlwZSwgcGF0aCB9ID0gT2JqZWN0LmFzc2lnbih7IHBhdGg6IFtdIH0sIGV2LmRhdGEpO1xuICAgICAgICBjb25zdCBhcmd1bWVudExpc3QgPSAoZXYuZGF0YS5hcmd1bWVudExpc3QgfHwgW10pLm1hcChmcm9tV2lyZVZhbHVlKTtcbiAgICAgICAgbGV0IHJldHVyblZhbHVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gcGF0aC5zbGljZSgwLCAtMSkucmVkdWNlKChvYmosIHByb3ApID0+IG9ialtwcm9wXSwgb2JqKTtcbiAgICAgICAgICAgIGNvbnN0IHJhd1ZhbHVlID0gcGF0aC5yZWR1Y2UoKG9iaiwgcHJvcCkgPT4gb2JqW3Byb3BdLCBvYmopO1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcIkdFVFwiIC8qIE1lc3NhZ2VUeXBlLkdFVCAqLzpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSByYXdWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiU0VUXCIgLyogTWVzc2FnZVR5cGUuU0VUICovOlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRbcGF0aC5zbGljZSgtMSlbMF1dID0gZnJvbVdpcmVWYWx1ZShldi5kYXRhLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiQVBQTFlcIiAvKiBNZXNzYWdlVHlwZS5BUFBMWSAqLzpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSByYXdWYWx1ZS5hcHBseShwYXJlbnQsIGFyZ3VtZW50TGlzdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIkNPTlNUUlVDVFwiIC8qIE1lc3NhZ2VUeXBlLkNPTlNUUlVDVCAqLzpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBuZXcgcmF3VmFsdWUoLi4uYXJndW1lbnRMaXN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblZhbHVlID0gcHJveHkodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJFTkRQT0lOVFwiIC8qIE1lc3NhZ2VUeXBlLkVORFBPSU5UICovOlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHBvcnQxLCBwb3J0MiB9ID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHBvc2Uob2JqLCBwb3J0Mik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZSA9IHRyYW5zZmVyKHBvcnQxLCBbcG9ydDFdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiUkVMRUFTRVwiIC8qIE1lc3NhZ2VUeXBlLlJFTEVBU0UgKi86XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVyblZhbHVlID0geyB2YWx1ZSwgW3Rocm93TWFya2VyXTogMCB9O1xuICAgICAgICB9XG4gICAgICAgIFByb21pc2UucmVzb2x2ZShyZXR1cm5WYWx1ZSlcbiAgICAgICAgICAgIC5jYXRjaCgodmFsdWUpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlLCBbdGhyb3dNYXJrZXJdOiAwIH07XG4gICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigocmV0dXJuVmFsdWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IFt3aXJlVmFsdWUsIHRyYW5zZmVyYWJsZXNdID0gdG9XaXJlVmFsdWUocmV0dXJuVmFsdWUpO1xuICAgICAgICAgICAgZXAucG9zdE1lc3NhZ2UoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB3aXJlVmFsdWUpLCB7IGlkIH0pLCB0cmFuc2ZlcmFibGVzKTtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcIlJFTEVBU0VcIiAvKiBNZXNzYWdlVHlwZS5SRUxFQVNFICovKSB7XG4gICAgICAgICAgICAgICAgLy8gZGV0YWNoIGFuZCBkZWFjdGl2ZSBhZnRlciBzZW5kaW5nIHJlbGVhc2UgcmVzcG9uc2UgYWJvdmUuXG4gICAgICAgICAgICAgICAgZXAucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIGNsb3NlRW5kUG9pbnQoZXApO1xuICAgICAgICAgICAgICAgIGlmIChmaW5hbGl6ZXIgaW4gb2JqICYmIHR5cGVvZiBvYmpbZmluYWxpemVyXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIG9ialtmaW5hbGl6ZXJdKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgLy8gU2VuZCBTZXJpYWxpemF0aW9uIEVycm9yIFRvIENhbGxlclxuICAgICAgICAgICAgY29uc3QgW3dpcmVWYWx1ZSwgdHJhbnNmZXJhYmxlc10gPSB0b1dpcmVWYWx1ZSh7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG5ldyBUeXBlRXJyb3IoXCJVbnNlcmlhbGl6YWJsZSByZXR1cm4gdmFsdWVcIiksXG4gICAgICAgICAgICAgICAgW3Rocm93TWFya2VyXTogMCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZXAucG9zdE1lc3NhZ2UoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB3aXJlVmFsdWUpLCB7IGlkIH0pLCB0cmFuc2ZlcmFibGVzKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgaWYgKGVwLnN0YXJ0KSB7XG4gICAgICAgIGVwLnN0YXJ0KCk7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNNZXNzYWdlUG9ydChlbmRwb2ludCkge1xuICAgIHJldHVybiBlbmRwb2ludC5jb25zdHJ1Y3Rvci5uYW1lID09PSBcIk1lc3NhZ2VQb3J0XCI7XG59XG5mdW5jdGlvbiBjbG9zZUVuZFBvaW50KGVuZHBvaW50KSB7XG4gICAgaWYgKGlzTWVzc2FnZVBvcnQoZW5kcG9pbnQpKVxuICAgICAgICBlbmRwb2ludC5jbG9zZSgpO1xufVxuZnVuY3Rpb24gd3JhcChlcCwgdGFyZ2V0KSB7XG4gICAgY29uc3QgcGVuZGluZ0xpc3RlbmVycyA9IG5ldyBNYXAoKTtcbiAgICBlcC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBmdW5jdGlvbiBoYW5kbGVNZXNzYWdlKGV2KSB7XG4gICAgICAgIGNvbnN0IHsgZGF0YSB9ID0gZXY7XG4gICAgICAgIGlmICghZGF0YSB8fCAhZGF0YS5pZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc29sdmVyID0gcGVuZGluZ0xpc3RlbmVycy5nZXQoZGF0YS5pZCk7XG4gICAgICAgIGlmICghcmVzb2x2ZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzb2x2ZXIoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBwZW5kaW5nTGlzdGVuZXJzLmRlbGV0ZShkYXRhLmlkKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBjcmVhdGVQcm94eShlcCwgcGVuZGluZ0xpc3RlbmVycywgW10sIHRhcmdldCk7XG59XG5mdW5jdGlvbiB0aHJvd0lmUHJveHlSZWxlYXNlZChpc1JlbGVhc2VkKSB7XG4gICAgaWYgKGlzUmVsZWFzZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHJveHkgaGFzIGJlZW4gcmVsZWFzZWQgYW5kIGlzIG5vdCB1c2VhYmxlXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlbGVhc2VFbmRwb2ludChlcCkge1xuICAgIHJldHVybiByZXF1ZXN0UmVzcG9uc2VNZXNzYWdlKGVwLCBuZXcgTWFwKCksIHtcbiAgICAgICAgdHlwZTogXCJSRUxFQVNFXCIgLyogTWVzc2FnZVR5cGUuUkVMRUFTRSAqLyxcbiAgICB9KS50aGVuKCgpID0+IHtcbiAgICAgICAgY2xvc2VFbmRQb2ludChlcCk7XG4gICAgfSk7XG59XG5jb25zdCBwcm94eUNvdW50ZXIgPSBuZXcgV2Vha01hcCgpO1xuY29uc3QgcHJveHlGaW5hbGl6ZXJzID0gXCJGaW5hbGl6YXRpb25SZWdpc3RyeVwiIGluIGdsb2JhbFRoaXMgJiZcbiAgICBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkoKGVwKSA9PiB7XG4gICAgICAgIGNvbnN0IG5ld0NvdW50ID0gKHByb3h5Q291bnRlci5nZXQoZXApIHx8IDApIC0gMTtcbiAgICAgICAgcHJveHlDb3VudGVyLnNldChlcCwgbmV3Q291bnQpO1xuICAgICAgICBpZiAobmV3Q291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHJlbGVhc2VFbmRwb2ludChlcCk7XG4gICAgICAgIH1cbiAgICB9KTtcbmZ1bmN0aW9uIHJlZ2lzdGVyUHJveHkocHJveHksIGVwKSB7XG4gICAgY29uc3QgbmV3Q291bnQgPSAocHJveHlDb3VudGVyLmdldChlcCkgfHwgMCkgKyAxO1xuICAgIHByb3h5Q291bnRlci5zZXQoZXAsIG5ld0NvdW50KTtcbiAgICBpZiAocHJveHlGaW5hbGl6ZXJzKSB7XG4gICAgICAgIHByb3h5RmluYWxpemVycy5yZWdpc3Rlcihwcm94eSwgZXAsIHByb3h5KTtcbiAgICB9XG59XG5mdW5jdGlvbiB1bnJlZ2lzdGVyUHJveHkocHJveHkpIHtcbiAgICBpZiAocHJveHlGaW5hbGl6ZXJzKSB7XG4gICAgICAgIHByb3h5RmluYWxpemVycy51bnJlZ2lzdGVyKHByb3h5KTtcbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVQcm94eShlcCwgcGVuZGluZ0xpc3RlbmVycywgcGF0aCA9IFtdLCB0YXJnZXQgPSBmdW5jdGlvbiAoKSB7IH0pIHtcbiAgICBsZXQgaXNQcm94eVJlbGVhc2VkID0gZmFsc2U7XG4gICAgY29uc3QgcHJveHkgPSBuZXcgUHJveHkodGFyZ2V0LCB7XG4gICAgICAgIGdldChfdGFyZ2V0LCBwcm9wKSB7XG4gICAgICAgICAgICB0aHJvd0lmUHJveHlSZWxlYXNlZChpc1Byb3h5UmVsZWFzZWQpO1xuICAgICAgICAgICAgaWYgKHByb3AgPT09IHJlbGVhc2VQcm94eSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHVucmVnaXN0ZXJQcm94eShwcm94eSk7XG4gICAgICAgICAgICAgICAgICAgIHJlbGVhc2VFbmRwb2ludChlcCk7XG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmdMaXN0ZW5lcnMuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICAgICAgaXNQcm94eVJlbGVhc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByb3AgPT09IFwidGhlblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHRoZW46ICgpID0+IHByb3h5IH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHIgPSByZXF1ZXN0UmVzcG9uc2VNZXNzYWdlKGVwLCBwZW5kaW5nTGlzdGVuZXJzLCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiR0VUXCIgLyogTWVzc2FnZVR5cGUuR0VUICovLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLm1hcCgocCkgPT4gcC50b1N0cmluZygpKSxcbiAgICAgICAgICAgICAgICB9KS50aGVuKGZyb21XaXJlVmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiByLnRoZW4uYmluZChyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVQcm94eShlcCwgcGVuZGluZ0xpc3RlbmVycywgWy4uLnBhdGgsIHByb3BdKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0KF90YXJnZXQsIHByb3AsIHJhd1ZhbHVlKSB7XG4gICAgICAgICAgICB0aHJvd0lmUHJveHlSZWxlYXNlZChpc1Byb3h5UmVsZWFzZWQpO1xuICAgICAgICAgICAgLy8gRklYTUU6IEVTNiBQcm94eSBIYW5kbGVyIGBzZXRgIG1ldGhvZHMgYXJlIHN1cHBvc2VkIHRvIHJldHVybiBhXG4gICAgICAgICAgICAvLyBib29sZWFuLiBUbyBzaG93IGdvb2Qgd2lsbCwgd2UgcmV0dXJuIHRydWUgYXN5bmNocm9ub3VzbHkgwq9cXF8o44OEKV8vwq9cbiAgICAgICAgICAgIGNvbnN0IFt2YWx1ZSwgdHJhbnNmZXJhYmxlc10gPSB0b1dpcmVWYWx1ZShyYXdWYWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVxdWVzdFJlc3BvbnNlTWVzc2FnZShlcCwgcGVuZGluZ0xpc3RlbmVycywge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiU0VUXCIgLyogTWVzc2FnZVR5cGUuU0VUICovLFxuICAgICAgICAgICAgICAgIHBhdGg6IFsuLi5wYXRoLCBwcm9wXS5tYXAoKHApID0+IHAudG9TdHJpbmcoKSksXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICB9LCB0cmFuc2ZlcmFibGVzKS50aGVuKGZyb21XaXJlVmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBhcHBseShfdGFyZ2V0LCBfdGhpc0FyZywgcmF3QXJndW1lbnRMaXN0KSB7XG4gICAgICAgICAgICB0aHJvd0lmUHJveHlSZWxlYXNlZChpc1Byb3h5UmVsZWFzZWQpO1xuICAgICAgICAgICAgY29uc3QgbGFzdCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGlmIChsYXN0ID09PSBjcmVhdGVFbmRwb2ludCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXF1ZXN0UmVzcG9uc2VNZXNzYWdlKGVwLCBwZW5kaW5nTGlzdGVuZXJzLCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiRU5EUE9JTlRcIiAvKiBNZXNzYWdlVHlwZS5FTkRQT0lOVCAqLyxcbiAgICAgICAgICAgICAgICB9KS50aGVuKGZyb21XaXJlVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2UganVzdCBwcmV0ZW5kIHRoYXQgYGJpbmQoKWAgZGlkbuKAmXQgaGFwcGVuLlxuICAgICAgICAgICAgaWYgKGxhc3QgPT09IFwiYmluZFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVByb3h5KGVwLCBwZW5kaW5nTGlzdGVuZXJzLCBwYXRoLnNsaWNlKDAsIC0xKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBbYXJndW1lbnRMaXN0LCB0cmFuc2ZlcmFibGVzXSA9IHByb2Nlc3NBcmd1bWVudHMocmF3QXJndW1lbnRMaXN0KTtcbiAgICAgICAgICAgIHJldHVybiByZXF1ZXN0UmVzcG9uc2VNZXNzYWdlKGVwLCBwZW5kaW5nTGlzdGVuZXJzLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJBUFBMWVwiIC8qIE1lc3NhZ2VUeXBlLkFQUExZICovLFxuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgubWFwKChwKSA9PiBwLnRvU3RyaW5nKCkpLFxuICAgICAgICAgICAgICAgIGFyZ3VtZW50TGlzdCxcbiAgICAgICAgICAgIH0sIHRyYW5zZmVyYWJsZXMpLnRoZW4oZnJvbVdpcmVWYWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbnN0cnVjdChfdGFyZ2V0LCByYXdBcmd1bWVudExpc3QpIHtcbiAgICAgICAgICAgIHRocm93SWZQcm94eVJlbGVhc2VkKGlzUHJveHlSZWxlYXNlZCk7XG4gICAgICAgICAgICBjb25zdCBbYXJndW1lbnRMaXN0LCB0cmFuc2ZlcmFibGVzXSA9IHByb2Nlc3NBcmd1bWVudHMocmF3QXJndW1lbnRMaXN0KTtcbiAgICAgICAgICAgIHJldHVybiByZXF1ZXN0UmVzcG9uc2VNZXNzYWdlKGVwLCBwZW5kaW5nTGlzdGVuZXJzLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJDT05TVFJVQ1RcIiAvKiBNZXNzYWdlVHlwZS5DT05TVFJVQ1QgKi8sXG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aC5tYXAoKHApID0+IHAudG9TdHJpbmcoKSksXG4gICAgICAgICAgICAgICAgYXJndW1lbnRMaXN0LFxuICAgICAgICAgICAgfSwgdHJhbnNmZXJhYmxlcykudGhlbihmcm9tV2lyZVZhbHVlKTtcbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICByZWdpc3RlclByb3h5KHByb3h5LCBlcCk7XG4gICAgcmV0dXJuIHByb3h5O1xufVxuZnVuY3Rpb24gbXlGbGF0KGFycikge1xuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBhcnIpO1xufVxuZnVuY3Rpb24gcHJvY2Vzc0FyZ3VtZW50cyhhcmd1bWVudExpc3QpIHtcbiAgICBjb25zdCBwcm9jZXNzZWQgPSBhcmd1bWVudExpc3QubWFwKHRvV2lyZVZhbHVlKTtcbiAgICByZXR1cm4gW3Byb2Nlc3NlZC5tYXAoKHYpID0+IHZbMF0pLCBteUZsYXQocHJvY2Vzc2VkLm1hcCgodikgPT4gdlsxXSkpXTtcbn1cbmNvbnN0IHRyYW5zZmVyQ2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gdHJhbnNmZXIob2JqLCB0cmFuc2ZlcnMpIHtcbiAgICB0cmFuc2ZlckNhY2hlLnNldChvYmosIHRyYW5zZmVycyk7XG4gICAgcmV0dXJuIG9iajtcbn1cbmZ1bmN0aW9uIHByb3h5KG9iaikge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKG9iaiwgeyBbcHJveHlNYXJrZXJdOiB0cnVlIH0pO1xufVxuZnVuY3Rpb24gd2luZG93RW5kcG9pbnQodywgY29udGV4dCA9IGdsb2JhbFRoaXMsIHRhcmdldE9yaWdpbiA9IFwiKlwiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcG9zdE1lc3NhZ2U6IChtc2csIHRyYW5zZmVyYWJsZXMpID0+IHcucG9zdE1lc3NhZ2UobXNnLCB0YXJnZXRPcmlnaW4sIHRyYW5zZmVyYWJsZXMpLFxuICAgICAgICBhZGRFdmVudExpc3RlbmVyOiBjb250ZXh0LmFkZEV2ZW50TGlzdGVuZXIuYmluZChjb250ZXh0KSxcbiAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcjogY29udGV4dC5yZW1vdmVFdmVudExpc3RlbmVyLmJpbmQoY29udGV4dCksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHRvV2lyZVZhbHVlKHZhbHVlKSB7XG4gICAgZm9yIChjb25zdCBbbmFtZSwgaGFuZGxlcl0gb2YgdHJhbnNmZXJIYW5kbGVycykge1xuICAgICAgICBpZiAoaGFuZGxlci5jYW5IYW5kbGUodmFsdWUpKSB7XG4gICAgICAgICAgICBjb25zdCBbc2VyaWFsaXplZFZhbHVlLCB0cmFuc2ZlcmFibGVzXSA9IGhhbmRsZXIuc2VyaWFsaXplKHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIkhBTkRMRVJcIiAvKiBXaXJlVmFsdWVUeXBlLkhBTkRMRVIgKi8sXG4gICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBzZXJpYWxpemVkVmFsdWUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0cmFuc2ZlcmFibGVzLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW1xuICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiBcIlJBV1wiIC8qIFdpcmVWYWx1ZVR5cGUuUkFXICovLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgIH0sXG4gICAgICAgIHRyYW5zZmVyQ2FjaGUuZ2V0KHZhbHVlKSB8fCBbXSxcbiAgICBdO1xufVxuZnVuY3Rpb24gZnJvbVdpcmVWYWx1ZSh2YWx1ZSkge1xuICAgIHN3aXRjaCAodmFsdWUudHlwZSkge1xuICAgICAgICBjYXNlIFwiSEFORExFUlwiIC8qIFdpcmVWYWx1ZVR5cGUuSEFORExFUiAqLzpcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2ZlckhhbmRsZXJzLmdldCh2YWx1ZS5uYW1lKS5kZXNlcmlhbGl6ZSh2YWx1ZS52YWx1ZSk7XG4gICAgICAgIGNhc2UgXCJSQVdcIiAvKiBXaXJlVmFsdWVUeXBlLlJBVyAqLzpcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS52YWx1ZTtcbiAgICB9XG59XG5mdW5jdGlvbiByZXF1ZXN0UmVzcG9uc2VNZXNzYWdlKGVwLCBwZW5kaW5nTGlzdGVuZXJzLCBtc2csIHRyYW5zZmVycykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICBjb25zdCBpZCA9IGdlbmVyYXRlVVVJRCgpO1xuICAgICAgICBwZW5kaW5nTGlzdGVuZXJzLnNldChpZCwgcmVzb2x2ZSk7XG4gICAgICAgIGlmIChlcC5zdGFydCkge1xuICAgICAgICAgICAgZXAuc3RhcnQoKTtcbiAgICAgICAgfVxuICAgICAgICBlcC5wb3N0TWVzc2FnZShPYmplY3QuYXNzaWduKHsgaWQgfSwgbXNnKSwgdHJhbnNmZXJzKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlVVVJRCgpIHtcbiAgICByZXR1cm4gbmV3IEFycmF5KDQpXG4gICAgICAgIC5maWxsKDApXG4gICAgICAgIC5tYXAoKCkgPT4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpLnRvU3RyaW5nKDE2KSlcbiAgICAgICAgLmpvaW4oXCItXCIpO1xufVxuXG5leHBvcnQgeyBjcmVhdGVFbmRwb2ludCwgZXhwb3NlLCBmaW5hbGl6ZXIsIHByb3h5LCBwcm94eU1hcmtlciwgcmVsZWFzZVByb3h5LCB0cmFuc2ZlciwgdHJhbnNmZXJIYW5kbGVycywgd2luZG93RW5kcG9pbnQsIHdyYXAgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbWxpbmsubWpzLm1hcFxuIl0sIm5hbWVzIjpbInByb3h5TWFya2VyIiwiU3ltYm9sIiwiY3JlYXRlRW5kcG9pbnQiLCJyZWxlYXNlUHJveHkiLCJmaW5hbGl6ZXIiLCJ0aHJvd01hcmtlciIsImlzT2JqZWN0IiwidmFsIiwicHJveHlUcmFuc2ZlckhhbmRsZXIiLCJjYW5IYW5kbGUiLCJzZXJpYWxpemUiLCJvYmoiLCJwb3J0MSIsInBvcnQyIiwiTWVzc2FnZUNoYW5uZWwiLCJleHBvc2UiLCJkZXNlcmlhbGl6ZSIsInBvcnQiLCJzdGFydCIsIndyYXAiLCJ0aHJvd1RyYW5zZmVySGFuZGxlciIsInZhbHVlIiwic2VyaWFsaXplZCIsIkVycm9yIiwiaXNFcnJvciIsIm1lc3NhZ2UiLCJuYW1lIiwic3RhY2siLCJPYmplY3QiLCJhc3NpZ24iLCJ0cmFuc2ZlckhhbmRsZXJzIiwiTWFwIiwiaXNBbGxvd2VkT3JpZ2luIiwiYWxsb3dlZE9yaWdpbnMiLCJvcmlnaW4iLCJhbGxvd2VkT3JpZ2luIiwiUmVnRXhwIiwidGVzdCIsImVwIiwiZ2xvYmFsVGhpcyIsImFkZEV2ZW50TGlzdGVuZXIiLCJjYWxsYmFjayIsImV2IiwiZGF0YSIsImNvbnNvbGUiLCJ3YXJuIiwiaWQiLCJ0eXBlIiwicGF0aCIsImFyZ3VtZW50TGlzdCIsIm1hcCIsImZyb21XaXJlVmFsdWUiLCJyZXR1cm5WYWx1ZSIsInBhcmVudCIsInNsaWNlIiwicmVkdWNlIiwicHJvcCIsInJhd1ZhbHVlIiwiYXBwbHkiLCJwcm94eSIsInRyYW5zZmVyIiwidW5kZWZpbmVkIiwiUHJvbWlzZSIsInJlc29sdmUiLCJjYXRjaCIsInRoZW4iLCJ3aXJlVmFsdWUiLCJ0cmFuc2ZlcmFibGVzIiwidG9XaXJlVmFsdWUiLCJwb3N0TWVzc2FnZSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJjbG9zZUVuZFBvaW50IiwiZXJyb3IiLCJUeXBlRXJyb3IiLCJpc01lc3NhZ2VQb3J0IiwiZW5kcG9pbnQiLCJjb25zdHJ1Y3RvciIsImNsb3NlIiwidGFyZ2V0IiwicGVuZGluZ0xpc3RlbmVycyIsImhhbmRsZU1lc3NhZ2UiLCJyZXNvbHZlciIsImdldCIsImRlbGV0ZSIsImNyZWF0ZVByb3h5IiwidGhyb3dJZlByb3h5UmVsZWFzZWQiLCJpc1JlbGVhc2VkIiwicmVsZWFzZUVuZHBvaW50IiwicmVxdWVzdFJlc3BvbnNlTWVzc2FnZSIsInByb3h5Q291bnRlciIsIldlYWtNYXAiLCJwcm94eUZpbmFsaXplcnMiLCJGaW5hbGl6YXRpb25SZWdpc3RyeSIsIm5ld0NvdW50Iiwic2V0IiwicmVnaXN0ZXJQcm94eSIsInJlZ2lzdGVyIiwidW5yZWdpc3RlclByb3h5IiwidW5yZWdpc3RlciIsImlzUHJveHlSZWxlYXNlZCIsIlByb3h5IiwiX3RhcmdldCIsImNsZWFyIiwibGVuZ3RoIiwiciIsInAiLCJ0b1N0cmluZyIsImJpbmQiLCJfdGhpc0FyZyIsInJhd0FyZ3VtZW50TGlzdCIsImxhc3QiLCJwcm9jZXNzQXJndW1lbnRzIiwiY29uc3RydWN0IiwibXlGbGF0IiwiYXJyIiwiQXJyYXkiLCJwcm90b3R5cGUiLCJjb25jYXQiLCJwcm9jZXNzZWQiLCJ2IiwidHJhbnNmZXJDYWNoZSIsInRyYW5zZmVycyIsIndpbmRvd0VuZHBvaW50IiwidyIsImNvbnRleHQiLCJ0YXJnZXRPcmlnaW4iLCJtc2ciLCJoYW5kbGVyIiwic2VyaWFsaXplZFZhbHVlIiwiZ2VuZXJhdGVVVUlEIiwiZmlsbCIsIk1hdGgiLCJmbG9vciIsInJhbmRvbSIsIk51bWJlciIsIk1BWF9TQUZFX0lOVEVHRVIiLCJqb2luIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/comlink/dist/esm/comlink.mjs\n");

/***/ })

};
;